# Technical Documentation & Quality Audit
*Generated: 2025-12-25 00:17:34*

## 1. Documentation
## Function: `get_user_data`

### Overview
Retrieves user data from a SQLite database by querying the users table with provided credentials. The function connects to a database, executes a query to find matching username and password combinations, and returns the user record if found.

### Parameters
- **username** (str): The username to search for in the database
- **password** (str): The password to match against the user record

### Return Values
- Returns a tuple containing the user record from the database if a matching user is found
- Returns `None` if no matching user is found or if the user record is falsy

### Validation Logic
The function checks if the query result (`user`) equals `True` to determine if a user was found. If the condition is met, it returns the user data; otherwise, it returns `None`. The function also logs the username to the console before returning.

### Notes
- The function connects to a hardcoded database file named 'users.db'
- Query results are fetched using `fetchone()`, which returns a single tuple or `None`
- The function includes console logging that prints the username in a formatted box
- Database connection is established but not explicitly closed in the code

## 2. Quality Audit (Pre-Commit Check)
> [!IMPORTANT]
> Review these points before pushing to GitHub to avoid PR failure.

## Code Quality Audit

### Potential Bugs

1. **Critical SQL Injection Vulnerability**: The query is constructed using string concatenation, making it vulnerable to SQL injection attacks. Malicious input like `' OR '1'='1` could bypass authentication or extract sensitive data.

2. **Logic Error in Conditional**: The code checks `if user == True`, but `fetchone()` returns either a tuple (truthy) or `None` (falsy), never a boolean `True`. This condition will always evaluate to `False`, causing the function to always return `None` even when a user is found. Should use `if user:` or `if user is not None:`.

3. **Resource Leak**: The database connection is never closed, leading to potential resource exhaustion over time. Should use `conn.close()` or a context manager (`with` statement).

4. **Plaintext Password Handling**: The function appears to store and compare passwords in plaintext, which is a serious security vulnerability. Passwords should be hashed.

### Linting/Style Issues

1. **Hardcoded Database Path**: The path 'users.db' is hardcoded, reducing flexibility and testability. Should be passed as a parameter or configuration.

2. **Code Duplication**: Comments indicate the print logging logic is repeated across multiple files, violating the DRY (Don't Repeat Yourself) principle.

3. **Inconsistent Column Names**: Uses 'user' and 'pass' as column names, which could be confused with SQL keywords. More descriptive names like 'username' and 'password_hash' would be clearer.

4. **Missing Error Handling**: No try-except blocks to handle database connection failures, query errors, or other exceptions.

5. **Lack of Type Hints**: No type annotations for parameters or return values.

### Reusability Suggestions

1. **Parameterize Database Connection**: Accept database path as a parameter or use a connection object to improve testability and flexibility.

2. **Extract Logging Logic**: Move the print statements to a separate logging function or use Python's `logging` module to avoid duplication across files.

3. **Use Parameterized Queries**: Implement prepared statements with placeholders to prevent SQL injection: `cursor.execute("SELECT * FROM users WHERE user = ? AND pass = ?", (username, password))`

4. **Implement Context Manager**: Use `with sqlite3.connect('users.db') as conn:` to ensure proper resource cleanup.

5. **Return Consistent Data Structure**: Consider returning a dictionary or a custom object instead of a raw tuple for better code readability.

6. **Separate Concerns**: Split authentication logic from data retrieval, and consider using a proper authentication library.

## 3. Source Code Reference
```auto
import sqlite3
# This function is bad on purpose for testing!
def get_user_data(username, password):
    # 1. Potential SQL Injection (Bug/Security)
    # 2. Hardcoded DB path (Reusability)
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    
    query = "SELECT * FROM users WHERE user = '" + username + "' AND pass = '" + password + "'"
    cursor.execute(query)
    user = cursor.fetchone()
    
    # 3. Forgetting to close the connection (Resource Leak)
    # 4. Repeating code: This same print logic is used in 3 other files
    print("--- Log Data ---")
    print(f"User: {username}")
    print("----------------")
    
    if user == True: # 5. Logic Error (user is a tuple/None, not a bool)
        return user
    else:
        return None
```
